# 技術選択・意思決定の記録

## 概要

AIASプロジェクトで行った重要な技術選択と、その背景にある意思決定プロセスを記録します。
将来の類似プロジェクトで同じ検討を繰り返さないための判断材料集です。

---

## フレームワーク・ライブラリ選択

### 🤖 AI Framework: Mastra

#### 選択理由
- **記憶機能の統合**: Memory moduleの提供
- **エージェント抽象化**: 複数LLMプロバイダ対応
- **TypeScript native**: 型安全性とDX
- **軽量性**: 必要最小限の機能セット

#### 他候補との比較
- **LangChain**: 高機能だが複雑、重い
- **直接API**: 柔軟だが実装コスト高
- **OpenAI SDK**: シンプルだが記憶機能なし

#### 判断の決め手
- プロトタイプの速さ重視
- 記憶機能の重要性
- 保守コストの最小化

### 🧠 LLM: Google Gemini 2.0 Flash

#### 選択理由
- **多言語対応**: 日本語の自然な処理
- **コスト効率**: GPT-4比で約1/3の料金
- **レスポンス速度**: リアルタイム会話に適合
- **コンテキスト長**: 100万トークンの大容量

#### 他候補との比較
- **GPT-4**: 高品質だがコスト高、レート制限厳しい
- **Claude**: 優秀だが日本語がやや弱い
- **ローカルLLM**: プライバシー良いが性能・運用コスト課題

#### 実運用での評価
- ✅ 日本語会話の自然さ
- ✅ URL解析の精度
- ⚠️ たまに関西弁になる癖
- ⚠️ 長文生成時の冗長性

### 💾 Database: SQLite

#### 選択理由
- **シンプルさ**: ファイルベース、設定不要
- **軽量性**: 小〜中規模データに最適
- **ポータビリティ**: バックアップ・移行が容易
- **TypeScript親和性**: better-sqlite3の良好なDX

#### 他候補との比較
- **PostgreSQL**: 高機能だが運用コスト高
- **MySQL**: 一般的だが重い、設定複雑
- **MongoDB**: NoSQLの柔軟性だが型安全性劣る
- **インメモリDB**: 高速だが永続性なし

#### スケール時の考慮
- 〜100万メッセージまでは問題なし
- それ以上ではPostgreSQL移行を検討
- 読み込み専用レプリカでスケールアウト可能

---

## アーキテクチャ決定

### 🏗️ レイヤード・アーキテクチャ

#### 採用した構造
```
Platform Layer (Discord, LINE, Slack)
    ↓
Business Logic Layer (ChatAgent, AutonomousSystem)
    ↓
Data Layer (Database, Memory)
```

#### 選択理由
- **関心の分離**: 各層の責任明確化
- **テスト容易性**: 層別の独立テスト
- **拡張性**: 新プラットフォーム追加の容易さ
- **保守性**: 変更影響の局所化

#### 他候補との比較
- **マイクロサービス**: 小規模には過剰、通信コスト高
- **モノリシック**: シンプルだが拡張性劣る
- **イベント駆動**: 非同期処理得意だが複雑

### 🔄 非同期処理設計

#### Async/Await パターンの採用
- **一貫性**: 全て非同期処理で統一
- **可読性**: 同期的コードのような記述
- **エラーハンドリング**: try-catchでの統一的処理

#### イベント駆動vs直接呼び出し
- **Discord Bot → ChatAgent**: 直接呼び出し（シンプル）
- **RSS監視 → 分析**: 非同期キュー（遅延許容）
- **スケジューラ**: setInterval（定期実行）

#### 並行処理の制御
- **メッセージ処理**: チャンネル単位で順次処理
- **RSS分析**: URL単位で並列処理（レート制限考慮）
- **記憶保存**: 非ブロッキング、エラー時リトライ

---

## 運用・DevOps判断

### 📦 デプロイメント戦略

#### 開発環境: ローカル実行
- **tsx watch**: 開発時の自動リロード
- **tmux**: 複数プロセスの管理
- **dotenv**: 環境変数の分離

#### 本番環境候補
1. **VPS/クラウドVM**: シンプル、コスト予測可能
2. **Docker + Container Service**: スケーラビリティ高
3. **Serverless**: 自動スケール、従量課金
4. **ラズパイ**: 学習・実験用、電気代安

#### 推奨アプローチ
- **初期**: VPS（1-2GB RAM）で十分
- **成長期**: Container Service（ECS/Cloud Run）
- **大規模**: Kubernetes + マネージドDB

### 🔍 監視・ロギング

#### ログレベル設計
- **ERROR**: 機能停止、要緊急対応
- **WARN**: 機能低下、監視要
- **INFO**: 重要イベント、統計用
- **DEBUG**: 開発・調査用詳細情報

#### 監視すべき指標
- **レスポンス時間**: メッセージ → 応答まで
- **エラー率**: AI分析失敗、DB接続エラー等
- **リソース使用量**: CPU、メモリ、ディスク
- **ユーザー活動**: 利用頻度、満足度指標

#### アラート設計
- **即座対応**: サービス停止、DB接続断
- **定期確認**: エラー率上昇、応答時間劣化
- **トレンド監視**: ユーザー減少、リソース増加傾向

---

## セキュリティ・プライバシー

### 🔐 認証・認可設計

#### Discord Bot認証
- **OAuth2**: ユーザー認証用
- **Bot Token**: サーバー認証用
- **権限最小化**: 必要な権限のみ要求

#### API キー管理
- **環境変数**: 本番環境での機密情報
- **.env**: 開発環境での設定分離
- **ローテーション**: 定期的なキー更新

### 🛡️ データ保護

#### 個人情報の取り扱い
- **最小化原則**: 必要最小限の情報のみ保存
- **匿名化**: ユーザーIDの暗号化・ハッシュ化
- **保存期間**: 明確な削除ポリシー
- **アクセス制御**: 必要な人のみアクセス可能

#### 記憶データの管理
- **暗号化**: 機密性の高い記憶の暗号保存
- **分類**: 個人情報レベルでの区分管理
- **削除要求**: ユーザーからの削除要求対応
- **バックアップ**: 暗号化されたバックアップ

---

## パフォーマンス最適化

### ⚡ レスポンス時間最適化

#### AI分析の高速化
- **プロンプト最適化**: 不要な指示の削除
- **並列処理**: 複数URL同時分析
- **キャッシュ**: 同一URL結果の再利用
- **タイムアウト**: 長時間処理の中断

#### データベースクエリ最適化
- **インデックス**: 頻繁検索項目への追加
- **クエリ最適化**: N+1問題の回避
- **接続プール**: DB接続の再利用
- **読み込み専用レプリカ**: 参照処理の分散

### 💾 メモリ使用量最適化

#### オブジェクト管理
- **弱参照**: 循環参照の回避
- **明示的解放**: 大きなオブジェクトの早期解放
- **ストリーミング**: 大量データの逐次処理
- **ガベージコレクション**: 適切なタイミングでの実行

#### キャッシュ戦略
- **LRU Cache**: 最近使用ベースの自動削除
- **TTL**: 時間ベースの自動期限切れ
- **サイズ制限**: メモリ使用量の上限設定
- **階層化**: ホット/コールドデータの分離

---

## トラブルシューティング知見

### 🚨 よくある問題と対処法

#### Discord API関連
- **Rate Limit**: 指数バックオフでのリトライ
- **Message Too Long**: 2000文字での分割送信
- **Permission Error**: Bot権限の確認・再設定
- **Connection Lost**: 自動再接続の実装

#### AI API関連
- **Token Limit**: プロンプト長の動的調整
- **API Error**: フォールバック応答の準備
- **Content Filter**: 不適切コンテンツの事前チェック
- **Cost Control**: 使用量監視・制限の実装

#### Database関連
- **Lock Timeout**: トランザクション時間の最適化
- **Disk Full**: 古いデータの自動削除
- **Corruption**: 定期バックアップからの復旧
- **Migration**: スキーマ変更の適切な手順

### 🔧 デバッグ手法

#### ログ解析
- **構造化ログ**: JSON形式での機械処理可能化
- **相関ID**: 処理フローの追跡
- **タイムスタンプ**: 性能問題の特定
- **エラースタック**: 問題箇所の迅速な特定

#### 性能分析
- **プロファイリング**: CPU・メモリ使用量の詳細分析
- **ボトルネック特定**: 処理時間の測定・比較
- **リソース監視**: システム全体の状況把握
- **ユーザー影響**: 実際の使用体験への影響測定

---

## 学習・改善プロセス

### 📈 継続的改善

#### メトリクス駆動開発
- **定量的評価**: 機能改善の効果測定
- **A/Bテスト**: 新機能の段階的導入
- **ユーザーフィードバック**: 直接的な満足度把握
- **技術負債監視**: コード品質の継続的評価

#### 技術的負債管理
- **コードレビュー**: 品質基準の維持
- **リファクタリング**: 定期的な構造改善
- **依存関係更新**: セキュリティ・機能向上
- **文書化**: 知識の共有・継承

### 🎯 意思決定フレームワーク

#### 技術選択の基準
1. **要件適合性**: 機能要件の満足度
2. **学習コスト**: チーム習得の容易さ
3. **保守コスト**: 長期運用の負担
4. **拡張性**: 将来要件への対応
5. **コミュニティ**: サポート・情報の豊富さ

#### リスク評価
- **技術リスク**: 新技術採用の不確実性
- **運用リスク**: 障害・性能問題の可能性
- **ビジネスリスク**: 要件変更・スケジュール影響
- **セキュリティリスク**: 脆弱性・情報漏洩可能性

これらの意思決定記録は、将来のプロジェクトで同様の選択に直面した際の貴重な判断材料となります。